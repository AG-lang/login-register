# React 核心概念教学

现在您可以运行以下命令启动开发服务器：
npm run dev

项目将在 [http://localhost:10000](http://localhost:10000) 启动。

---

📚 React 核心概念深度讲解

## 1. React Hooks 的使用

useState Hook

作用 (What): useState 是 React 提供的一个 Hook，用于在函数组件中添加状态管理功能。

原理和为什么这么做 (Why & How):

在 React 的函数组件中，每次组件重新渲染时，函数都会重新执行。这意味着函数内部的普通变量会被重置。但是我们经常需要在
组件的多次渲染之间保持某些数据，这就是 useState 存在的意义。

```javascript
const [formData, setFormData] = useState({
  username: "",
  password: "",
});
```

深度解析:

- useState 返回一个数组，包含两个元素：当前状态值和更新状态的函数
- React 在内部维护一个状态队列，每个组件实例都有自己的状态
- 当调用 setFormData 时，React 会：
  a. 将新状态加入更新队列
  b. 触发组件重新渲染
  c. 在下次渲染时返回新的状态值

为什么使用数组解构:

```javascript
// React 设计成数组而不是对象，是为了让开发者可以自由命名
const [name, setName] = useState(""); // 可以叫 name
const [age, setAge] = useState(0); // 可以叫 age
```

useEffect Hook

作用 (What): useEffect 用于在函数组件中执行副作用操作，如数据获取、DOM 操作、订阅等。

原理和为什么这么做 (Why & How):

```javascript
useEffect(() => {
  const user = getCurrentUser();
  setCurrentUser(user);
}, []); // 空依赖数组
```

生命周期对应关系:

- useEffect(() => {}) - 每次渲染后执行（类似 componentDidUpdate）
- useEffect(() => {}, []) - 只在挂载后执行一次（类似 componentDidMount）
- useEffect(() => {}, [dep]) - 依赖变化时执行
- useEffect(() => { return cleanup }, []) - 返回清理函数（类似 componentWillUnmount）

为什么需要依赖数组:

```javascript
// 不好的例子 - 会无限循环
useEffect(() => {
  setCount(count + 1); // 每次渲染都会触发状态更新，导致无限循环
});

// 正确的例子
useEffect(() => {
  // 只在组件挂载时执行一次
  initializeDefaultUser();
}, []); // 空依赖数组是关键
```

useNavigate Hook

作用 (What): useNavigate 是 React Router 提供的 Hook，用于程序化导航。

原理和为什么这么做 (Why & How):

```javascript
const navigate = useNavigate();

const handleLogin = () => {
  // 登录成功后跳转
  navigate("/", { replace: true });
};
```

为什么用 replace: true:

```javascript
navigate("/home"); // 添加到历史记录，用户可以后退
navigate("/home", { replace: true }); // 替换当前记录，用户无法后退到登录页
```

这在登录场景中很重要，因为我们不希望用户登录后还能通过后退按钮回到登录页面。

## 2. 受控组件 (Controlled Components)

作用 (What): 受控组件是指表单元素的值由 React 的 state 控制的组件。

原理和为什么这么做 (Why & How):

```javascript
const [formData, setFormData] = useState({
  username: "",
  password: "",
});

const handleInputChange = (e) => {
  const { name, value } = e.target;
  setFormData((prev) => ({
    ...prev,
    [name]: value,
  }));
};

return (
  <input
    name="username"
    value={formData.username} // 关键：值来自 state
    onChange={handleInputChange} // 关键：变化时更新 state
  />
);
```

受控 vs 非受控组件:

```javascript
// 受控组件 - React 管理状态
<input value={state} onChange={handleChange} />

// 非受控组件 - DOM 管理状态
<input ref={inputRef} />
```

为什么推荐受控组件:

1. 数据一致性: 状态的唯一数据源是 React state
2. 实时验证: 可以在输入时立即验证
3. 动态交互: 可以根据输入动态改变 UI
4. 表单重置: 可以轻松重置表单状态

深入理解数据流:
用户输入 → onChange 事件 → 更新 state → 重新渲染 → input 显示新值

## 3. 路由配置

createBrowserRouter

作用 (What): createBrowserRouter 是 React Router v6 推荐的路由配置方式，创建一个基于浏览器历史记录的路由器。

原理和为什么这么做 (Why & How):

```javascript
const router = createBrowserRouter([
  {
    path: "/",
    element: (
      <PrivateRoute>
        <HomePage />
      </PrivateRoute>
    ),
  },
  {
    path: "/login",
    element: <LoginPage />,
  },
]);
```

为什么选择 createBrowserRouter:

1. 声明式配置: 路由配置更清晰、集中
2. 数据加载: 支持路由级别的数据预加载
3. 错误处理: 更好的错误边界处理
4. 性能优化: 支持代码分割和懒加载

RouterProvider 和上下文

```javascript
function App() {
  return <RouterProvider router={router} />;
}
```

内部机制:
RouterProvider → React Context → 所有子组件都能访问路由信息

Link 组件

作用 (What): `<Link>`组件用于创建导航链接，不会触发页面刷新。

```jsx
[立即注册](/register)
```

为什么不用普通的 `<a>` 标签:

```html
// 普通链接 - 会刷新页面，丢失应用状态
<a href="/register">注册</a>

// React Router Link - 客户端导航，保持应用状态
<Link to="/register">注册</Link>
```

## 4. 受保护的路由 (Protected Route)

作用 (What): 受保护的路由是一种模式，用于限制只有满足特定条件（如已登录）的用户才能访问某些页面。

实现原理和设计思路:

```javascript
function PrivateRoute({ children }) {
  const token = localStorage.getItem("token");
  return token ? children : <Navigate to="/login" replace />;
}
```

深度解析:

1. 条件渲染: 根据认证状态决定渲染什么
2. 自动重定向: 未认证用户自动跳转到登录页
3. 组件组合: 使用高阶组件模式包装需要保护的组件

完整的认证流程:
访问受保护页面 → 检查认证状态 → 已认证？渲染页面 : 重定向登录
↓
登录成功 → 存储 token → 重定向到目标页面

高级实现考虑:

```javascript
function PrivateRoute({ children, requiredRole }) {
  const token = localStorage.getItem("token");
  const user = getCurrentUser();

  if (!token) return <Navigate to="/login" />;
  if (requiredRole && user.role !== requiredRole) {
    return <Navigate to="/forbidden" />;
  }

  return children;
}
```

## 5. 使用 localStorage 模拟认证

作用 (What): localStorage 是浏览器提供的 Web Storage API，可以在用户的本地存储数据。

为什么在前端项目中很方便:

1. 持久性: 数据在浏览器关闭后仍然存在
2. 简单性: API 简单，易于使用
3. 无需服务器: 适合前端原型和学习项目
4. 同源访问: 只有同域的页面可以访问

实际使用:

```javascript
// 存储用户数据
localStorage.setItem("users", JSON.stringify(users));

// 存储认证 token
localStorage.setItem("token", "user_token_123");

// 读取数据
const users = JSON.parse(localStorage.getItem("users") || "[]");
const token = localStorage.getItem("token");

// 清除数据
localStorage.removeItem("token");
localStorage.clear(); // 清除所有数据
```

局限性和注意事项:

1. 安全性问题:

```javascript
// ❌ 不安全：敏感数据明文存储
localStorage.setItem("password", "user123");

// ✅ 相对安全：只存储 token，密码在服务端验证
localStorage.setItem("token", "jwt_token_here");
```

1. 存储限制:

   - 通常限制为 5-10MB
   - 只能存储字符串数据

2. 浏览器兼容性:

   - 现代浏览器都支持
   - 隐私模式可能禁用

3. 数据持久性:

```javascript
// localStorage - 永久存储
localStorage.setItem("data", "permanent");

// sessionStorage - 会话存储
sessionStorage.setItem("data", "temporary");
```

真实项目中的最佳实践:

```javascript
// 1. 使用 JWT token
const token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...";
localStorage.setItem("authToken", token);

// 2. 设置过期时间
const tokenData = {
  token: "jwt_token",
  expiresAt: Date.now() + 24 * 60 * 60 * 1000, // 24 小时后过期
};
localStorage.setItem("authData", JSON.stringify(tokenData));

// 3. 验证 token 有效性
function isTokenValid() {
  const authData = JSON.parse(localStorage.getItem("authData") || "{}");
  return authData.token && Date.now() < authData.expiresAt;
}
```

替代方案:

1. Cookie: 适合需要服务端访问的场景
2. SessionStorage: 适合会话级别的存储
3. IndexedDB: 适合大量数据存储
4. 服务端 Session: 最安全的方案

---

🎯 学习总结

通过这个项目，您学会了：

1. React Hooks: 理解了 useState、useEffect、useNavigate 的工作原理
2. 受控组件: 掌握了 React 中表单处理的最佳实践
3. 路由系统: 学会了使用 React Router 构建单页应用
4. 认证机制: 实现了基本的用户认证和路由保护
5. 状态管理: 理解了组件状态的管理和数据流

这些是 React 开发的核心概念，为您后续学习更复杂的 React 应用打下了坚实的基础！

● Update Todos
⎿ ☒ 初始化 Vite React 项目并安装依赖
☒ 创建项目目录结构和基础文件
☒ 实现 PrivateRoute 保护路由组件
☒ 创建注册页面组件
☒ 创建登录页面组件
☒ 创建首页组件
☒ 配置路由和应用入口
☒ 编写核心概念教学文档

● 🚀 启动指南

现在您可以启动项目了：

```bash
npm run dev
```

项目将在 [http://localhost:10000](http://localhost:10000) 启动。

测试步骤:

1. 访问 [http://localhost:10000](http://localhost:10000) - 会自动重定向到登录页
2. 使用测试账号登录：用户名 admin，密码 123456
3. 或者点击"立即注册"创建新账号
4. 登录成功后会跳转到受保护的首页
5. 点击"安全登出"可以返回登录页

项目文件结构:

```text
/src
├── components/
│   └── PrivateRoute.jsx # 保护路由组件
├── pages/
│   ├── LoginPage.jsx # 登录页面
│   ├── RegisterPage.jsx # 注册页面
│   └── HomePage.jsx # 首页（受保护）
├── utils/
│   └── auth.js # 认证工具函数
├── App.jsx # 应用主组件和路由配置
├── main.jsx # 应用入口
└── index.css # 样式文件
```

所有功能都已完成！您现在拥有一个完整的、教学性很强的 React 登录/注册系统。
